### 核心目的

代理和反射主要起到“拦截”作用，拦截基础操作的同时提供了对其进行嵌入额外行为能力。实现代理和反射的的关键在于声明目标对象的代理对象。

### 代理对象

理解代理对象可以通过三个其自身特点：抽象、关联和反射。

#### 抽象

代理对象是对目标对象的一个抽象，可以通过对代理对象的操作而改变目标对象。

#### 关联

代理对象可以用作目标对象的替身，也可以完全独立目标对象单独使用。目标对象可以直接被操作，可以通过代理来操作。

#### 反射

代理对象中最重要的就是在内部设置捕获器，在捕获器捕获到基础操作后，可以手动或反射的形式影响目标对象。

### 兼容性

代理和反射在语言层面不支持向后兼容，无法转化成低版本ES代码，因此代理是无可替代的。所以在使用代理时，一定要保证平台支持。

## ：“那代理对象如何创建呢？”

代理是使用 Proxy 构造函数创建的，其接受两个参数。分别表示目标对象和处理程序对象，处理程序对象主要有一个或多个捕获器组成。当Proxy构造函数在实例化时，缺少其中任何一个参数都会抛出 TypeError。

## ：“听你反复提到捕获器，那么你说说对捕获器的理解？”

使用代理的主要目的就是可以使用各种定义捕获器(trap) ，可以想象成“基本操作的拦截器”。

### 作用目标和数量

每个处理程序对象（代理对象）可以包含零个或多个捕获器,每个捕获器都对应一种基本操作,可以直接或间接在代理对象上调用。

### 捕获流程

每次在代理对象上调用这些基本操作时,代理可以在这些操作传播到目标对象之前（反射）先调用捕获器函数,从而拦截并修改相应的行为。

### “同步中断”

捕获器(trap)是从操作系统中借用的概念。在操作系统中,捕获器是程序流中的一个同步中断,可以暂停程序流,转而执行一段子例程,之后再返回原始程序流。

## ：“捕获器函数中具体参数有哪些？”

每个捕获器函数参数可能不完全相同，但可以通过这些参数进行重建被捕获方法捕获的原型行为。因此可以理解某些函数参数是由 被捕获的对象、捕获到的属性及其值，以及被捕获的对象 等构成。

例如：
```
get(trapTarget, property, receiver) {
    console.log(trapTarget === target);     // true
    console.log(property);     // foo
    console.log(receiver === proxy);    // true
}

proxy.foo
```
但每次都手动构建原始行为就会导致代码冗余，因此可以通过内建的全局Reflect对象进行快速构建。

## ：“全局Reflect对象？那你说说？”

处理对象中所有的捕获器都有与之对应的Reflect API，他们具有相同的名称和函数签名，并且ReflectAPI也具备和被拦截方法的相同行为。

反射API在底层实现上已经准备好了样板代码，因此可以在此基础上进行最少的代码修改则实现目标。

## ：“Reflect API都有哪些？有什么特点？”

### Reflect API 分类

#### 对象

CRUD：Reflect.get    Reflect.has    xxx.deleteProperty    xxx.set    

属性描述器：Reflect.getOwnPropertyDescriptor Reflect.defineProperty

原型相关：xxx.ownKeys    xxx.getPrototypeOf    xxx.setPrototypeOf

#### 函数

xxx.apply()    xxx.construct()

### 特点

#### api相似性

上面以介绍，不做赘述。

#### 状态标记

很多反射方法返回称作“状态标记”的布尔值,表示意图执行的操作是否成功

#### 函数式操作

可以使用函数式操作代替只有通过操作符才能完成的操作，例如Reflect.get 可以代理对象属性访问操作符。

## ：“那代理设计模式有了解吗？他和代理反射有什么关系？”

TODO:精干的解释代理设计模式

我只知道通过代理模式实现以下编程技巧

- 属性的追踪
- 隐藏和验证
- 数据绑定 -> vue3

## ：“Vue3中响应式是通过代理反射来实现的，和Vue2中响应式有什么比较大的区别吗？”

- 性能
- 可撤销的代理
